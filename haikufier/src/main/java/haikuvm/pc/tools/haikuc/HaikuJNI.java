package haikuvm.pc.tools.haikuc;

import haikuvm.pc.tools.Haikufy;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;

import org.apache.bcel.classfile.Attribute;
import org.apache.bcel.classfile.ClassFormatException;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.classfile.Unknown;
import org.apache.bcel.generic.Type;

public class HaikuJNI {

    private PrintOnChange jni;

    private PrintOnChange natives;

    private PrintOnChange nativeCF;

    private String cType;

    private Type[] at;

    private String jniName;

    private String objType;

    private boolean Cpp;

    public HaikuJNI(String dir) throws FileNotFoundException {
        jni=new PrintOnChange(new File(dir+"/"+Haikufy.choice("haikuC")+"/haikuJNI.c"));
        jni.println("#if justAsCutAndPastSource__CanBeDonePerClassAlsoWith__javah");
        jni.println();
        jni.println("/* DO NOT EDIT THIS FILE it is machine generated */");
        jni.println("#include <jni.h>");
        jni.println("/* Header for all classes */");
        jni.println("#ifndef _Included_allClasses");
        jni.println("#define _Included_allClasses");
        jni.println("#ifdef __cplusplus");
        jni.println("extern \"C\" {");
        jni.println("#endif");
        jni.printf("\n");
        jni.printf("/////////////////////////////////////////////////\n");
        jni.printf("\n");
        jni.printf("\n");

        natives=jni;
//        natives=new PrintStream(new File(dir+"/"+Haikufy.choice("haikuC")+"/haikuNatives.c"));
//        natives.println("/* DO NOT EDIT THIS FILE – it is machine generated */");
//        natives.println("#include <jni.h>");
//        natives.println("#ifdef __cplusplus");
//        natives.println("extern \"C\" {");
//        natives.println("#endif");
//        natives.printf("\n");
//        natives.printf("/////////////////////////////////////////////////\n");
//        natives.printf("\n");
        
        nativeCF=new PrintOnChange(new File(dir+"/"+Haikufy.choice("haikuC")+"/NativeCFunctions.cpp"));
        nativeCF.println("#include <jni.h>");
        nativeCF.println("#include <math.h>");
        nativeCF.println("#include <string.h>");
        nativeCF.printf("\n");
        nativeCF.printf("/////////////////////////////////////////////////\n");
        nativeCF.printf("\n");
        nativeCF.printf("\n");
  }

    public void close() throws IOException {
        jni.println("#ifdef __cplusplus");
        jni.println("}");
        jni.println("#endif");
        jni.println("#endif");
        jni.println();
        jni.println("#endif");
        jni.close();
        nativeCF.close();

//        natives.println("#ifdef __cplusplus");
//        natives.println("}");
//        natives.println("#endif");
//        natives.close();
    }
    
    private String stackType(Type type) {
        if (type==Type.DOUBLE)  return "d";
        if (type==Type.LONG)    return "j";
        if (type==Type.INT)     return "i";
        if (type==Type.SHORT)   return "s";
        if (type==Type.BYTE)    return "b";
        if (type==Type.BOOLEAN) return "z";
        if (type==Type.CHAR)    return "c";
        if (type==Type.FLOAT)   return "f";
        return "a";
    }

    private String getMethAnnotations(String classname, String methname) throws IOException {
        String res="";
        JavaClass ljc = Haikufy.getClassFile(classname);
        Method[] methods = ljc.getMethods();
        for (int i = 0; i < methods.length; i++) {
            Method f = methods[i];
            if (methname.equals(f.getName()+" "+f.getSignature())) {
                Attribute[] a = f.getAttributes();
                for (int j = 0; j < a.length; j++) {
                    System.out.println(a[j]);
                    if (a[j].toString().contains(" RuntimeVisibleAnnotations:")) {                          
                        byte[] x = ((Unknown)a[j]).getBytes();
                        int idx=((x[2]&0xff)<<8)+(x[3]&0xff);
                        res+=a[j].getConstantPool().getConstant(idx);
//                        for (int k = 0; k <1000; k++) {
//                            try {
//                                System.out.println("inner["+k+"]: "+a[j].getConstantPool().getConstant(k));
//                            } catch (ClassFormatError e) {
//                            } catch (ClassFormatException e) {
//                            }
//                        }
                    }
                }
//                System.out.println();
            }
        }
        return res;
    }

    public void nativeInfo(String classname, Method method, String cMethodName) throws IOException {
        nativeInfo0(classname, method, cMethodName);
        directCFunction(classname, method, cMethodName);
    }

    /**
     * support for annotation NativeCFunction
     */
    private void directCFunction(String classname, Method method, String cMethodName) throws IOException {
        String annotation=getMethAnnotations(classname, method.getName()+" "+method.getSignature());
        
        // extern ["C" ]
        if (annotation.contains("NativeCFunction")) {
            Cpp=false;
            nativeCF.printf("#ifndef "+method.getName()+"\n");
            nativeCF.printf("extern \"C\" ");
        } else if (annotation.contains("NativeCppFunction")) {
            Cpp=true;
            nativeCF.printf("#ifndef "+method.getName()+"\n");
            nativeCF.printf("extern ");
        } else {
            return;
        }

        // extern ["C" ] int
        classname=classname.replace('/', '.').replace('\\', '.');
        if (method.getReturnType()!=Type.VOID) {
            nativeCF.printf(basicCtype(cType)+" ");
        } else {
            nativeCF.printf("void ");
        }

        // extern ["C" ] int putchar(
        nativeCF.printf(method.getName()+"(");
        // extern ["C" ] int putchar(int
        for (int i = 0; i<at.length; i++) {
            if (i>0) nativeCF.printf(", ");
            nativeCF.printf(basicCtype(at[i].toString()));
        }
        // extern ["C" ] int putchar(int);
        nativeCF.printf(");\n");
        nativeCF.printf("#endif\n");
        
        
        nativeCF.printf("\n");
        nativeCF.printf("/*\n");
        nativeCF.printf(" * Class:     %s\n", classname);
        nativeCF.printf(" * Method:    %s\n", method.getName());
        nativeCF.printf(" * Signature: %s\n", method.getSignature());
        nativeCF.printf(" */\n");
        nativeCF.printf("JNIEXPORT %s %s\n  (JNIEnv *env, %s obj", cType, jniName, objType);
        for (int i = 0; i<at.length; i++) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            nativeCF.printf(", %s arg%d", paramType, i+1);
        }
        nativeCF.printf(")\n{\n");
        if (method.getReturnType()!=Type.VOID) {
            nativeCF.printf("    return ");
        } else {
            nativeCF.printf("    ");
        }
        if (cType.equals("jdouble")) {
            nativeCF.printf("DOUBLE2TD(");
        }
        if (cType.equals("jfloat")) {
            nativeCF.printf("FLOAT2TF(");
        }
        
        nativeCF.printf(method.getName()+"(");
        for (int i = 0; i<at.length; i++) {
            if (i>0) nativeCF.printf(", ");
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (paramType.equals("jdouble")) {
                nativeCF.printf("TD2DOUBLE(");
            }
            if (paramType.equals("jfloat")) {
                nativeCF.printf("TF2FLOAT(");
            }
            nativeCF.printf("arg%d", i+1);
            if (paramType.equals("jdouble") || paramType.equals("jfloat")) {
                nativeCF.printf(")");
            }
        }
        
        if (cType.equals("jdouble") || cType.equals("jfloat")) {
            nativeCF.printf(")");
        }
        nativeCF.printf(");\n");

        nativeCF.printf("}\n");
        nativeCF.printf("\n");
        propAccess(nativeCF, classname, method, cMethodName);
    }

    private String basicCtype(String javaType) {
        String paramType = Haikufy.signature2JNI(javaType);
        paramType=paramType.replace("jobject", "void *");
        paramType=paramType.replace("jbyte", "jchar");
        if (Cpp) {
            paramType=paramType.replaceFirst("j", "unsigned ");
        } else {
            paramType=paramType.replaceFirst("j", "");
        }
        return paramType;
    }

    private void nativeInfo0(String classname, Method method, String cMethodName) throws IOException {
        classname=classname.replace('/', '.').replace('\\', '.');
        String name = method.getName();
        int pos=cMethodName.lastIndexOf("_"+name+"_");
        jniName = "Java_"+cMethodName.substring(0, pos+name.length()+1);     
        objType="jobject";
        if (method.isStatic()) {
            objType="jclass";
        }
        if (method.getReturnType()==Type.VOID) {
            cType = "void";
        } else {
            cType = Haikufy.signature2JNI(method.getReturnType().toString());
            if (stackType(method.getReturnType()).equals("a")) {
                cType = "jobject";
            }
        }
        at = method.getArgumentTypes();
        
        
        jni.printf("/*\n");
        jni.printf(" * Class:     %s\n", classname);
        jni.printf(" * Method:    %s\n", method.getName());
        jni.printf(" * Signature: %s\n", method.getSignature());
        jni.printf(" */\n");
        jni.printf("JNIEXPORT %s %s\n  (JNIEnv *, %s", cType, jniName, objType);
        for (int i = 0; i<at.length; i++) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            jni.printf(", %s", paramType);
        }
        jni.printf(");\n");
        jni.printf("\n");

        
        jni.printf("JNIEXPORT %s %s\n  (JNIEnv *env, %s obj", cType, jniName, objType);
        for (int i = 0; i<at.length; i++) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            jni.printf(", %s arg%d", paramType, i+1);
        }
        jni.printf(")\n{\n");
        jni.printf("    // TODO: insert your code here\n");
        if (method.getReturnType()!=Type.VOID) {
            if (cType.equals("jobject")) {
                jni.printf("    return NULL;\n");
            } else {
                jni.printf("    return 0;\n");
            }
        }
        jni.printf("}\n");
        jni.printf("\n");
//        jni.printf("/////////////////////////////////////////////////\n");
//        jni.printf("\n");
//        jni.printf("\n");
        
//        if (cMethodName.equals("java_lang_Thread_setStateAndSwitch_II")) {
//            natives.printf("// void native_%s(void) // is special! don't overwrite the inner definition\n", cMethodName);
//        } else {
//        }

//        natives.printf("/*\n");
//        natives.printf(" * Class:     %s\n", classname);
//        natives.printf(" * Method:    %s\n", method.getName());
//        natives.printf(" * Signature: %s\n", method.getSignature());
//        natives.printf(" */\n");
//        natives.printf("JNIEXPORT %s %s\n  (JNIEnv *, %s", cType, jniName, objType);
//        for (int i = 0; i<at.length; i++) {
//            String paramType = Haikufy.signature2JNI(at[i].toString());
//            if (stackType(at[i]).equals("a")) {
//                paramType = "jobject";
//            }
//            natives.printf(", %s", paramType);
//        }
//        natives.printf(");\n");
//        natives.printf("\n");

        propAccess(natives, classname, method, cMethodName);
    }

    private void propAccess(PrintOnChange natives2, String classname, Method method, String cMethodName) {
        natives2.printf("/*\n");
        natives2.printf(" * Proprietary HaikuVM stack to JNI interface function.\n");
        natives2.printf(" * DO NOT EDIT THIS FUNCTION – it is machine generated.\n");
        natives2.printf(" * \n");
        natives2.printf(" * Class:     %s\n", classname);
        natives2.printf(" * Method:    %s\n", method.getName());
        natives2.printf(" * Signature: %s\n", method.getSignature());
        natives2.printf(" */\n");
        natives2.printf("JNIEXPORT void native_%s(void) {\n", cMethodName);
        natives2.printf("    pushTop();    // Save variable top onto stack.\n");
        natives2.printf("    {\n");

        for (int i = at.length-1; i>=0; i--) {
            String paramType = Haikufy.signature2JNI(at[i].toString());
            if (stackType(at[i]).equals("a")) {
                paramType = "jobject";
            }
            String sType = stackType(at[i]);
            if (at[i]==Type.DOUBLE || at[i]==Type.LONG) {
                natives2.printf("        %s    arg%d = popp2()->%s;\n", paramType, i+1, sType);
            } else {
                natives2.printf("        %s    arg%d = pop()->%s;\n", paramType, i+1, sType);
            }
        }
        String args = "";
        for (int i = 0; i<at.length; i++) {
            args+=", arg"+(i+1);
        }

        if (method.isStatic()) {
            natives2.printf("        jclass     obj = NULL;\n");
        } else {
            natives2.printf("        jobject    obj = pop()->a;\n");
        }
        natives2.printf("        JNIEnv     *env = NULL; // not used in HaikuVM\n");
        
        
        if (method.getReturnType()==Type.VOID) {
            natives2.printf("        %s(env, obj%s);\n", jniName, args);
            natives2.printf("    }\n");
            natives2.printf("    popTop();\n");
        } else {
            String sType = stackType(method.getReturnType());
            if (sType.equals("j") || sType.equals("d")) {
                natives2.printf("        top.%s = %s(env, obj%s);\n", sType, jniName, args);
                natives2.printf("    }\n");
                natives2.printf("    // Variable top holds the return value. But we have to push the lower half.\n");
                natives2.printf("    pushTop0();\n");
            } else {
                natives2.printf("        top.%s = %s(env, obj%s);\n", "s1."+sType, jniName, args);
                natives2.printf("    }\n");
                natives2.printf("    // Variable top holds the return value.\n");
            }
        }
        natives2.printf("}\n");
        natives2.printf("\n");
        natives2.printf("/////////////////////////////////////////////////\n");
        natives2.printf("\n");
        natives2.printf("\n");
   }

}
